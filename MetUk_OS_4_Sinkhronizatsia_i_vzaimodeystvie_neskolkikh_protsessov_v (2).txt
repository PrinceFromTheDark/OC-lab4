Федеральное агентство РФ по образованию
Государственное образовательное учреждение 
Высшего профессионального образования
Донской государственный технический университет
Кафедра "ПОВТ и АС"




Синхронизация и взаимодействие нескольких процессов в среде Windows



Методические указания к лабораторной работе 
по дисциплине «Операционные системы и оболочки»










Ростов-на-Дону
Составители: к.т.н., доц. Долгов В.В.

УДК 512.3


Синхронизация и взаимодействие нескольких процессов в среде Unix: методические указания – Ростов н/Д: Издательский центр ДГТУ,– 8 с. 



В методической разработке рассматриваются способы синхронизации работы нескольких процессов и способы передачи данных между процессами в операционных системах семейства Unix. даны задания по выполнению лабораторной работы.  Методические указания предназначены для студентов специальностей 020303 "Математическое обеспечение и администрирование информационных систем" и 090304 «Программная инженерия»



Ответственный редактор: 	д.т.н., проф. Нейдорф Р.А.




? Издательский центр ДГТУ
1. Способы синхронизации работы процессов в среде Unix
К стандартным способам синхронизации работы нескольких процессов можно отнести такие объекты как критическая секция, событие, семафор. Каждый из этих способов обладает определенным функциональным наполнением и различным поведением. Так критическая секция предназначена для разграничения доступа к некоторому уникальному1 ресурсу нескольких процессов конкурирующих за этот ресурс. На практике, реализация механизма критической секции сводится к разделению во времени моментов выполнения участков различных процессов с помощью системных вызовов «Вход в критическую секцию»(Enter) и «Выход из критической секции»(Leave) (рис. 1).
рис. 1. Схема реализации механизма «критической секции»
В Unix-системах существуют несколько стандартных методов для синхронизации работы процессов. К ним относятся: семафоры, мьютексы и условные переменные. Каждый из этих методов имеет свои особенности и возможности.
Семафоры — это целочисленные переменные, которые используются для управления доступом к общему ресурсу. Они позволяют ограничить количество процессов, которые одновременно могут получить доступ к ресурсу. В Unix можно использовать POSIX-семафоры (counting_semaphore, semaphore.acquire(), semaphore.release()) или System V семафоры.
Пример реализации семафоров на языке C++ :
#include <iostream> 
#include <semaphore> 
#include <thread> 
using namespace std; 
  
// Инициализация семафора с счетом 3 
counting_semaphore<10> semaphore(3); 
  
void worker(int id) 
{ 
    // получение семафора 
    semaphore.acquire(); 
  
    // выполнение работы 
    cout << "Поток " << id << " захватил семафор."
         << endl; 
  
    // освобождение семафора 
    semaphore.release(); 
    cout << "Поток " << id << " освободил семафор."
         << endl; 
} 
  
// основной код 
int main() 
{ 
    thread t1(worker, 1); 
    thread t2(worker, 2); 
    thread t3(worker, 3); 
    t1.join(); 
    t2.join(); 
    t3.join(); 
    return 0; 
}

Результатом работы программы будет:
Поток 2 получил доступ к семафору. 
Поток 2 освободил семафор. 
Поток 1 получил доступ к семафору. 
Поток 1 освободил семафор. 
Поток 3 получил доступ к семафору. 
Поток 3 освободил семафор.

Мьютексы 
Пример реализации программы без мьютексов на языке C++ :
#include <iostream> 
#include <thread> 

using namespace std; 

// Разделяемый ресурс
int number = 0; 

// Функция для увеличения значения переменной number
void increment(){ 
    // Увеличиваем number на 1, выполняя это 1000000 раз
    for(int i=0; i<1000000; i++){ 
        number++; 
    } 
} 

int main() 
{ 
    // Создаём поток t1 для выполнения функции increment()
    thread t1(increment); 
    
    // Создаём поток t2 для выполнения функции increment()
    thread t2(increment); 
    
    // Запускаем оба потока одновременно
    t1.join(); 
    t2.join(); 
    
    // Выводим значение number после выполнения обоих потоков
    cout << "Число после выполнения t1 и t2 равно " << number; 
    
    return 0; 
}

Результатом работы программы будет:
Первый запуск:
Число после выполнения t1 и t2 равно 1058072.
Второй запуск:
Число после выполнения t1 и t2 равно 1456656
Третий запуск:
Число после выполнения t1 и t2 равно 2000000
Почему так происходит? Одновременный запуск двух потоков приводит к возникновению случаев гонки, которые приводят к непредсказуемому результату. Нет гарантии, что результат будет равен 2000000. Такое непредсказуемое поведение происходит из-за одновременного изменения одной и той же общей переменной одновременно несколькими потоками. Мьютексы представляют собой особый тип семафора, который обеспечивает эксклюзивный доступ к ресурсу. Они позволяют заблокировать ресурс, обеспечивая тем самым, что только один процесс может получить к нему доступ одновременно. Мьютексы в Unix могут быть реализованы с помощью pthread-библиотеки, используя pthread_mutex_lock() и pthread_mutex_unlock(). Для работы с мьютексами необходимо включить заголовочный файл pthread.h в начало скрипта, чтобы использовать все функции библиотеки pthreads. Чтобы выполнить файл c, необходимо использовать -pthread или -lpthread в командной строке во время компиляции файла:
cc -pthread file.c or
cc -lpthread file.c
Пример реализации на языке C++:
#include <iostream> 
#include <thread> 

using namespace std; 

// Импортируем мьютекс из стандартной библиотеки C++
#include <mutex> 

// Создаём объект для мьютекса
mutex mtx; 

// Разделяемый ресурс
int number = 0; 

// Функция для увеличения значения переменной number
void increment(){ 
    // Блокируем поток с помощью lock
    mtx.lock(); 
    
    // Увеличиваем number на 1, выполняя это 1000000 раз
    for(int i=0; i<1000000; i++){ 
        number++; 
    } 
    
    // Освобождаем блокировку с помощью unlock()
    mtx.unlock(); 
} 

int main() 
{ 
    // Создаём поток t1 для выполнения функции increment()
    thread t1(increment); 
    
    // Создаём поток t2 для выполнения функции increment()
    thread t2(increment); 
    
    // Запускаем оба потока одновременно
    t1.join(); 
    t2.join(); 
    
    // Выводим значение number после выполнения обоих потоков
    std::cout << "Число после выполнения t1 и t2 равно " << number; 
    
    return 0;
Результатом работы программы будет:
Первый запуск:
Первый запуск:
Число после выполнения t1 и t2 равно 2000000
Второй запуск:
Число после выполнения t1 и t2 равно 2000000
Третий запуск:
Число после выполнения t1 и t2 равно 2000000
Условные переменные - это примитив синхронизации, который используется для уведомления других потоков в многопоточной среде о том, что общий ресурс свободен для доступа. В C++ он определен как класс std::condition_variable внутри заголовочного файла <condition_variable>.
Методы условных переменных
Методы std::condition_variable содержат некоторые методы-члены для обеспечения базовых функциональных возможностей. Некоторые из них:
Номер функции
Функция
Описание
1
wait()
Эта функция указывает текущему потоку дождаться уведомления о переменной условия.
2
wait_for()
Эта функция сообщает текущему потоку, что он должен подождать некоторое определенное время. Если переменная условия получает уведомление раньше указанного времени, поток просыпается. Время указывается как относительное.
3
wait_until()
Эта функция аналогична функции wait_for(), но здесь длительность определяется как абсолютное время.
4
notify_one()
Эта функция уведомляет один из ожидающих потоков о том, что доступ к общему ресурсу свободен. Выбор потока осуществляется случайным образом.
5
notify_all()
Эта функция уведомляет все потоки.

Пример реализации условных переменных на языке C++:
#include <condition_variable>
#include <iostream>
#include <mutex>
#include <thread>

using namespace std;

// мьютекс для блокировки потоков
mutex mtx;
condition_variable cv;

// функция для избежания ложных пробуждений
bool data_ready = false;

// функция производитель, работающая как отправитель
void producer()
{
    // Симуляция производства данных
    this_thread::sleep_for(chrono::seconds(2));

    // освобождение блокировки
    lock_guard<mutex> lock(mtx);

    // переменная для избежания ложного пробуждения
    data_ready = true;

    // логирование уведомления в консоль
    cout << "Данные произведены!" << endl;

    // уведомление потребителя, когда всё готово
    cv.notify_one();
}

// потребитель, который будет потреблять то, что произвел производитель работающий как получатель
void consumer()
{
    // блокировка
    unique_lock<mutex> lock(mtx);

    // ожидание
    cv.wait(lock, [] { return data_ready; });

    cout << "Данные потреблены!" << endl;
}

// основной код
int main()
{
    thread consumer_thread(consumer);
    thread producer_thread(producer);

    consumer_thread.join();
    producer_thread.join();

    return 0;
}
Результатом работы программы будет:
Данные получены!
Данные потреблены!


ЗАДАНИЕ 1:
Реализовать процесс для вывода текстового файла на консоль. Считая консоль уникальным ресурсом, заблокировать её с помощью мьютекса. Запустить несколько экземпляров процесса и убедиться, что вывод информации на экран происходит только из одного экземпляра в одно и то же время.
ЗАДАНИЕ 2:
Создать два процесса, один из которых ожидает нажатия клавиши (к примеру, через интерфейс ncurses) и уведомляет другой процесс с помощью условной переменной. Второй процесс, дождевшись уведомления, должен вывести на экран сто разноцветных геометрических фигур.
ЗАДАНИЕ 3:
На заправочной станции имеется четыре топливных поста. Подсчитать, сколько машин не смогли заправиться, поскольку все места были заняты. Новая машина приезжает каждые 1-2 минуты, а время заправки одной машины составляет от 1 до 4 минут. Для контроля количества свободных мест используется семафор.
2. Средства взаимодействия процессов (IPC)
В Unix системах существует множество методов для обмена данными между процессами. Выбор конкретного способа должен зависеть от требований задачи.
Общая память (Shared Memory) — это один из самых быстрых методов передачи данных между процессами. Он позволяет нескольким процессам обращаться к одной области памяти. В Unix можно использовать функции shmget(), shmat(), shmdt() и shmctl() для работы с общей памятью.
Пример реализации общей памяти на запись на языке С++:
#include <iostream>
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
using namespace std;

int main()
{
    // ftok для генерации уникального ключа
    key_t key = ftok("shmfile", 65);

    // shmget возвращает идентификатор в shmid
    int shmid = shmget(key, 1024, 0666 | IPC_CREAT);

    // shmat для подключения к общей памяти
    char* str = (char*)shmat(shmid, (void*)0, 0);

    cout << "Введите данные : ";
    cin.getline(str, 1024);

    cout << "Данные записаны в память: " << str << endl;

    // отключение от общей памяти
    shmdt(str);

    return 0;
}
Результатом работы программы будет:
Введите данные : Привет, мир!
Данные записаны в память: Привет, мир!
Пример реализации общей памяти на чтение на языке С++:
#include <iostream>
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
using namespace std;

int main()
{
    // ftok для генерации уникального ключа
    key_t key = ftok("shmfile", 65);

    // shmget возвращает идентификатор в shmid
    int shmid = shmget(key, 1024, 0666 | IPC_CREAT);

    // shmat для подключения к общей памяти
    char* str = (char*)shmat(shmid, (void*)0, 0);

    cout << "Данные, считываемые из памяти:" << str;

    // отключение от общей памяти
    shmdt(str);

    // уничтожение общей памяти
    shmctl(shmid, IPC_RMID, NULL);

    return 0;
}
Результатом работы программы будет:
Если данные в общей памяти отсутствуют:
Данные, считываемые из памяти:
Если данные уже были записаны в общую память (по предыдущему запуску программы, например: «Привет, мир!»):
Данные, считываемые из памяти: Привет, мир!

Каналы (Pipes) и именованные каналы (Named Pipes) используются для потокового обмена данными между процессами. Обычные каналы создаются с помощью pipe(), а именованные каналы — с помощью mkfifo().
Пример применения обычных каналов на языке C++:
#include <iostream>
#include <unistd.h>
#include <cstring>

int main() {
    int pipefd[2];
    pid_t pid;
    char buffer[128];

    if (pipe(pipefd) == -1) {
        perror("pipe");
        return 1;
    }

    pid = fork();
    if (pid == -1) {
        perror("fork");
        return 1;
    }

    if (pid == 0) {  // Ребенок
        close(pipefd[1]); // Закрываем конец записи
        read(pipefd[0], buffer, sizeof(buffer));
        std::cout << "Дочерний процесс прочитал: " << buffer << std::endl;
        close(pipefd[0]);
    } else {  // Родитель
        close(pipefd[0]); // Закрываем конец чтения
        const char* msg = "Привет из родительского процесса!";
        write(pipefd[1], msg, strlen(msg) + 1);
        close(pipefd[1]);
    }

    return 0;
}
Результатом работы программы будет:
Дочерний процесс прочитал: Привет из родительского процесса!
Пример применения именованных каналов на языке С++:
#include <iostream>
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <cstring>

int main() {
    const char* fifoPath = "/tmp/my_fifo";
    
    // Создаем именованный канал (fifo)
    mkfifo(fifoPath, 0666);

    pid_t pid = fork();

    if (pid == -1) {
        perror("fork");
        return 1;
    }

    if (pid == 0) {  // Ребенок
        char buffer[128];
        int fd = open(fifoPath, O_RDONLY);
        read(fd, buffer, sizeof(buffer));
        std::cout << "Дочерний процесс прочитал: " << buffer << std::endl;
        close(fd);
    } else {  // Родитель
        int fd = open(fifoPath, O_WRONLY);
        const char* msg = "Привет из родительского процесса!";
        write(fd, msg, strlen(msg) + 1);
        close(fd);

        // Ждем, чтобы дочерний процесс успел прочитать
        wait(nullptr);
    }

    // Удаляем именованный канал
    unlink(fifoPath);
    return 0;
}
 Результатом работы программы будет:
Дочерний процесс прочитал: Привет из родительского процесса!
Примечание
Для именованных каналов (FIFO) вы можете дополнительно проверить, что файл FIFO был создан в /tmp/my_fifo, если вы хотите убедиться, что он действительно работает.
После завершения выполнения программы, файл именованного канала будет удален с помощью unlink.
Сокеты обеспечивают возможность взаимодействия между процессами, независимо от того, выполняются они на одном хосте или на разных. Сокеты могут использоваться для создания сетевых приложений и реализуются с помощью системных вызовов socket(), bind(), listen(), accept(), connect() и других.
Пример простой программы на C++, которая демонстрирует взаимодействие между сервером(server.cpp) и клиентом(client.cpp) с использованием сокетов. В этом примере сервер будет слушать входящие подключения на определенном порту, а клиент будет подключаться к этому серверу и отправлять сообщение.
Server.cpp:
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    char buffer[BUFFER_SIZE] = {0};

    // Создаем сокет
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("Ошибка создания сокета");
        exit(EXIT_FAILURE);
    }

    // Устанавливаем параметры сокета
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror("Ошибка установки параметров сокета");
        exit(EXIT_FAILURE);
    }

    // Задаем адрес и порт
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY; // Допускаем подключения из любого IP
    address.sin_port = htons(PORT); // Задаем порт

    // Привязываем сокет к адресу
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("Ошибка привязки сокета");
        exit(EXIT_FAILURE);
    }

    // Начинаем слушать входящие соединения
    if (listen(server_fd, 3) < 0) {
        perror("Ошибка прослушивания");
        exit(EXIT_FAILURE);
    }

    std::cout << "Сервер запущен. Ожидание подключения...\n";

    // Принимаем входящее подключение
    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen)) < 0) {
        perror("Ошибка при подключении");
        exit(EXIT_FAILURE);
    }

    // Читаем данные от клиента
    read(new_socket, buffer, BUFFER_SIZE);
    std::cout << "Сообщение от клиента: " << buffer << std::endl;

    // Закрываем сокет
    close(new_socket);
    close(server_fd);
    return 0;
}
Client.cpp:
#include <iostream>
#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080

int main() {
    int sock = 0;
    struct sockaddr_in serv_addr;

    // Создаем сокет
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        std::cout << "Ошибка создания сокета" << std::endl;
        return -1;
    }

    // Настраиваем адрес сервера
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);

    // Преобразуем IPv4 и IPv6 адреса из текстового представления в бинарное
    if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
        std::cout << "Неверный адрес/Адрес не поддерживается" << std::endl;
        return -1;
    }

    // Подключаемся к серверу
    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        std::cout << "Ошибка подключения" << std::endl;
        return -1;
    }

    // Отправляем сообщение серверу
    const char *message = "Привет от клиента!";
    send(sock, message, strlen(message), 0);
    std::cout << "Сообщение отправлено серверу\n";

    // Закрываем сокет
    close(sock);
    return 0;
}

ЗАДАНИЕ 1:
Написать процесс, осуществляющий копирование файлов (сервер копирования). Имена исходного файла и файла-назначения передаются процессу через именованный канал. Реализовать клиент для передачи задания на сервер копирования.
ЗАДАНИЕ 2:
Разработать два взаимодействующих приложения, которые осуществляют шифрацию/дешифрацию текста методом простой подстановки. Одно приложение (клиент) должно передавать текст в другое (сервер) и получать обработанные данные обратно.
ЗАДАНИЕ 3:
Разработать программу для игры в "Морской бой", где процесс будет взаимодействовать сам с собой через общую память.
ЗАДАНИЕ 4:
Реализовать ту же программу, но для взаимодействия использовать именованные каналы.
ЗАДАНИЕ 5:
Создать программу, которая рисует прямоугольники в окне с заданными координатами и цветами (сервер), получая задания от клиентской программы. Обеспечить правильное функционирование системы, реализовав синхронизацию с помощью мьютексов и передачу информации через общую память.
ЗАДАНИЕ 6:
Реализовать две программы: одна ведет связный двунаправленный список целых чисел в общей памяти, добавляя и удаляя элементы случайным образом, вторая сортирует список каждые 10 секунд и выводит результаты на экран. Для обеспечения целостности данных использовать мьютексы.

Литература
    1. А. Вильямс «Системное программирование в Windows 2000» - СПб.: Питер, 2001. – 624 с.

Редактор А.А. Литвинова
___________________________________________________________________
ЛР № 04779 от 18.05.01.		В набор  		В печать 
Объем 0,5 усл.п.л.,      уч.-изд.л.	Офсет.	 	Формат  60x84/16.
Бумага тип №3. 				Заказ №		Тираж 140.	Цена ___________________________________________________________________
Издательский центр ДГТУ
Адрес университета и полиграфического предприятия:
344010, г. Ростов-на-Дону, пл. гагарина, 1.
